--  Redistribution and use in source and binary forms, with or without modification,are permitted provided that the following conditions are met:1. Redistributions of source code must retain the above copyright notice, this list  of conditions and the following disclaimer.2. Redistributions in binary form must reproduce the above copyright notice, this  list of conditions and the following disclaimer in the documentation and/or  other materials provided with the distribution.3. Neither the name of the copyright holder nor the names of its  contributors may be used to endorse or promote products derived from this  software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" ANDANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE AREDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FORANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ONANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THISSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  

--  This spec has been automatically generated from MIMXRT1052.svd

pragma Restrictions (No_Elaboration_Code);
pragma Ada_2012;
pragma Style_Checks (Off);

with HAL;
with System;

package NRF_SVD.FlexSPI is
   pragma Preelaborate;

   ---------------
   -- Registers --
   ---------------

   --  Sample Clock source selection for Flash Reading
   type MCR0_RXCLKSRC_Field is
     (
      --  Dummy Read strobe generated by FlexSPI Controller and loopback
      --  internally.
      Rxclksrc_0,
      --  Dummy Read strobe generated by FlexSPI Controller and loopback from
      --  DQS pad.
      Rxclksrc_1,
      --  Flash provided Read strobe and input from DQS pad
      Rxclksrc_3)
     with Size => 2;
   for MCR0_RXCLKSRC_Field use
     (Rxclksrc_0 => 0,
      Rxclksrc_1 => 1,
      Rxclksrc_3 => 3);

   --  Enable AHB bus Read Access to IP RX FIFO.
   type MCR0_ARDFEN_Field is
     (
      --  IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX
      --  FIFO memory space will get bus error response.
      Ardfen_0,
      --  IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX
      --  FIFO memory space will always return data zero but no bus error
      --  response.
      Ardfen_1)
     with Size => 1;
   for MCR0_ARDFEN_Field use
     (Ardfen_0 => 0,
      Ardfen_1 => 1);

   --  Enable AHB bus Write Access to IP TX FIFO.
   type MCR0_ATDFEN_Field is
     (
      --  IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX
      --  FIFO memory space will get bus error response.
      Atdfen_0,
      --  IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX
      --  FIFO memory space will be ignored but no bus error response.
      Atdfen_1)
     with Size => 1;
   for MCR0_ATDFEN_Field use
     (Atdfen_0 => 0,
      Atdfen_1 => 1);

   --  Half Speed Serial Flash access Enable.
   type MCR0_HSEN_Field is
     (
      --  Disable divide by 2 of serial flash clock for half speed commands.
      Hsen_0,
      --  Enable divide by 2 of serial flash clock for half speed commands.
      Hsen_1)
     with Size => 1;
   for MCR0_HSEN_Field use
     (Hsen_0 => 0,
      Hsen_1 => 1);

   --  Doze mode enable bit
   type MCR0_DOZEEN_Field is
     (
      --  Doze mode support disabled. AHB clock and serial clock will not be
      --  gated off when there is doze mode request from system.
      Dozeen_0,
      --  Doze mode support enabled. AHB clock and serial clock will be gated
      --  off when there is doze mode request from system.
      Dozeen_1)
     with Size => 1;
   for MCR0_DOZEEN_Field use
     (Dozeen_0 => 0,
      Dozeen_1 => 1);

   --  This bit is to support Flash Octal mode access by combining Port A and B
   --  Data pins (SIOA[3:0] and SIOB[3:0]).
   type MCR0_COMBINATIONEN_Field is
     (
      --  Disable.
      Combinationen_0,
      --  Enable.
      Combinationen_1)
     with Size => 1;
   for MCR0_COMBINATIONEN_Field use
     (Combinationen_0 => 0,
      Combinationen_1 => 1);

   --  This bit is used to force SCK output free-running. For FPGA
   --  applications, external device may use SCK clock as reference clock to
   --  its internal PLL. If SCK free-running is enabled, data sampling with
   --  loopback clock from SCK pad is not supported (MCR0[RXCLKSRC]=2).
   type MCR0_SCKFREERUNEN_Field is
     (
      --  Disable.
      Sckfreerunen_0,
      --  Enable.
      Sckfreerunen_1)
     with Size => 1;
   for MCR0_SCKFREERUNEN_Field use
     (Sckfreerunen_0 => 0,
      Sckfreerunen_1 => 1);

   subtype MCR0_IPGRANTWAIT_Field is HAL.UInt8;
   subtype MCR0_AHBGRANTWAIT_Field is HAL.UInt8;

   --  Module Control Register 0
   type MCR0_Register is record
      --  Software Reset
      SWRESET        : Boolean := False;
      --  Module Disable
      MDIS           : Boolean := True;
      --  unspecified
      Reserved_2_3   : HAL.UInt2 := 16#0#;
      --  Sample Clock source selection for Flash Reading
      RXCLKSRC       : MCR0_RXCLKSRC_Field := NRF_SVD.FlexSPI.Rxclksrc_0;
      --  Enable AHB bus Read Access to IP RX FIFO.
      ARDFEN         : MCR0_ARDFEN_Field := NRF_SVD.FlexSPI.Ardfen_1;
      --  Enable AHB bus Write Access to IP TX FIFO.
      ATDFEN         : MCR0_ATDFEN_Field := NRF_SVD.FlexSPI.Atdfen_1;
      --  unspecified
      Reserved_8_10  : HAL.UInt3 := 16#0#;
      --  Half Speed Serial Flash access Enable.
      HSEN           : MCR0_HSEN_Field := NRF_SVD.FlexSPI.Hsen_0;
      --  Doze mode enable bit
      DOZEEN         : MCR0_DOZEEN_Field := NRF_SVD.FlexSPI.Dozeen_0;
      --  This bit is to support Flash Octal mode access by combining Port A
      --  and B Data pins (SIOA[3:0] and SIOB[3:0]).
      COMBINATIONEN  : MCR0_COMBINATIONEN_Field :=
                        NRF_SVD.FlexSPI.Combinationen_0;
      --  This bit is used to force SCK output free-running. For FPGA
      --  applications, external device may use SCK clock as reference clock to
      --  its internal PLL. If SCK free-running is enabled, data sampling with
      --  loopback clock from SCK pad is not supported (MCR0[RXCLKSRC]=2).
      SCKFREERUNEN   : MCR0_SCKFREERUNEN_Field :=
                        NRF_SVD.FlexSPI.Sckfreerunen_0;
      --  unspecified
      Reserved_15_15 : HAL.Bit := 16#1#;
      --  Time out wait cycle for IP command grant.
      IPGRANTWAIT    : MCR0_IPGRANTWAIT_Field := 16#FF#;
      --  Timeout wait cycle for AHB command grant.
      AHBGRANTWAIT   : MCR0_AHBGRANTWAIT_Field := 16#FF#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for MCR0_Register use record
      SWRESET        at 0 range 0 .. 0;
      MDIS           at 0 range 1 .. 1;
      Reserved_2_3   at 0 range 2 .. 3;
      RXCLKSRC       at 0 range 4 .. 5;
      ARDFEN         at 0 range 6 .. 6;
      ATDFEN         at 0 range 7 .. 7;
      Reserved_8_10  at 0 range 8 .. 10;
      HSEN           at 0 range 11 .. 11;
      DOZEEN         at 0 range 12 .. 12;
      COMBINATIONEN  at 0 range 13 .. 13;
      SCKFREERUNEN   at 0 range 14 .. 14;
      Reserved_15_15 at 0 range 15 .. 15;
      IPGRANTWAIT    at 0 range 16 .. 23;
      AHBGRANTWAIT   at 0 range 24 .. 31;
   end record;

   subtype MCR1_AHBBUSWAIT_Field is HAL.UInt16;
   subtype MCR1_SEQWAIT_Field is HAL.UInt16;

   --  Module Control Register 1
   type MCR1_Register is record
      --  AHB Read/Write access to Serial Flash Memory space will timeout if
      --  not data received from Flash or data not transmited after AHBBUSWAIT
      --  * 1024 ahb clock cycles, AHB Bus will get an error response
      AHBBUSWAIT : MCR1_AHBBUSWAIT_Field := 16#FFFF#;
      --  Command Sequence Execution will timeout and abort after SEQWAIT *
      --  1024 Serial Root Clock cycles
      SEQWAIT    : MCR1_SEQWAIT_Field := 16#FFFF#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for MCR1_Register use record
      AHBBUSWAIT at 0 range 0 .. 15;
      SEQWAIT    at 0 range 16 .. 31;
   end record;

   --  This bit determines whether AHB RX Buffer and AHB TX Buffer will be
   --  cleaned automaticaly when FlexSPI returns STOP mode ACK. Software should
   --  set this bit if AHB RX Buffer or AHB TX Buffer will be powered off in
   --  STOP mode. Otherwise AHB read access after exiting STOP mode may hit AHB
   --  RX Buffer or AHB TX Buffer but their data entries are invalid.
   type MCR2_CLRAHBBUFOPT_Field is
     (
      --  AHB RX/TX Buffer will not be cleaned automatically when FlexSPI
      --  return Stop mode ACK.
      Clrahbbufopt_0,
      --  AHB RX/TX Buffer will be cleaned automatically when FlexSPI return
      --  Stop mode ACK.
      Clrahbbufopt_1)
     with Size => 1;
   for MCR2_CLRAHBBUFOPT_Field use
     (Clrahbbufopt_0 => 0,
      Clrahbbufopt_1 => 1);

   --  All external devices are same devices (both in types and size) for
   --  A1/A2/B1/B2.
   type MCR2_SAMEDEVICEEN_Field is
     (
      --  In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register
      --  setting will be applied to Flash A1/A2/B1/B2 seperately. In Parallel
      --  mode, FLSHA1CRx register setting will be applied to Flash A1 and B1,
      --  FLSHA2CRx register setting will be applied to Flash A2 and B2.
      --  FLSHB1CRx/FLSHB2CRx register settings will be ignored.
      Samedeviceen_0,
      --  FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to
      --  Flash A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
      Samedeviceen_1)
     with Size => 1;
   for MCR2_SAMEDEVICEEN_Field use
     (Samedeviceen_0 => 0,
      Samedeviceen_1 => 1);

   --  SCKB pad can be used as SCKA differential clock output (inverted clock
   --  to SCKA). In this case, port B flash access is not available. After
   --  change the value of this feild, MCR0[SWRESET] should be set.
   type MCR2_SCKBDIFFOPT_Field is
     (
      --  SCKB pad is used as port B SCK clock output. Port B flash access is
      --  available.
      Sckbdiffopt_0,
      --  SCKB pad is used as port A SCK inverted clock output (Differential
      --  clock to SCKA). Port B flash access is not available.
      Sckbdiffopt_1)
     with Size => 1;
   for MCR2_SCKBDIFFOPT_Field use
     (Sckbdiffopt_0 => 0,
      Sckbdiffopt_1 => 1);

   subtype MCR2_RESUMEWAIT_Field is HAL.UInt8;

   --  Module Control Register 2
   type MCR2_Register is record
      --  unspecified
      Reserved_0_10  : HAL.UInt11 := 16#1F7#;
      --  This bit determines whether AHB RX Buffer and AHB TX Buffer will be
      --  cleaned automaticaly when FlexSPI returns STOP mode ACK. Software
      --  should set this bit if AHB RX Buffer or AHB TX Buffer will be powered
      --  off in STOP mode. Otherwise AHB read access after exiting STOP mode
      --  may hit AHB RX Buffer or AHB TX Buffer but their data entries are
      --  invalid.
      CLRAHBBUFOPT   : MCR2_CLRAHBBUFOPT_Field :=
                        NRF_SVD.FlexSPI.Clrahbbufopt_0;
      --  unspecified
      Reserved_12_13 : HAL.UInt2 := 16#0#;
      --  The sampling clock phase selection will be reset to phase 0 when this
      --  bit is written with 0x1. This bit will be auto-cleared immediately.
      CLRLEARNPHASE  : Boolean := False;
      --  All external devices are same devices (both in types and size) for
      --  A1/A2/B1/B2.
      SAMEDEVICEEN   : MCR2_SAMEDEVICEEN_Field :=
                        NRF_SVD.FlexSPI.Samedeviceen_1;
      --  unspecified
      Reserved_16_18 : HAL.UInt3 := 16#0#;
      --  SCKB pad can be used as SCKA differential clock output (inverted
      --  clock to SCKA). In this case, port B flash access is not available.
      --  After change the value of this feild, MCR0[SWRESET] should be set.
      SCKBDIFFOPT    : MCR2_SCKBDIFFOPT_Field :=
                        NRF_SVD.FlexSPI.Sckbdiffopt_0;
      --  unspecified
      Reserved_20_23 : HAL.UInt4 := 16#0#;
      --  Wait cycle (in AHB clock cycle) for idle state before suspended
      --  command sequence resumed.
      RESUMEWAIT     : MCR2_RESUMEWAIT_Field := 16#20#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for MCR2_Register use record
      Reserved_0_10  at 0 range 0 .. 10;
      CLRAHBBUFOPT   at 0 range 11 .. 11;
      Reserved_12_13 at 0 range 12 .. 13;
      CLRLEARNPHASE  at 0 range 14 .. 14;
      SAMEDEVICEEN   at 0 range 15 .. 15;
      Reserved_16_18 at 0 range 16 .. 18;
      SCKBDIFFOPT    at 0 range 19 .. 19;
      Reserved_20_23 at 0 range 20 .. 23;
      RESUMEWAIT     at 0 range 24 .. 31;
   end record;

   --  Parallel mode enabled for AHB triggered Command (both read and write) .
   type AHBCR_APAREN_Field is
     (
      --  Flash will be accessed in Individual mode.
      Aparen_0,
      --  Flash will be accessed in Parallel mode.
      Aparen_1)
     with Size => 1;
   for AHBCR_APAREN_Field use
     (Aparen_0 => 0,
      Aparen_1 => 1);

   --  Enable AHB bus cachable read access support.
   type AHBCR_CACHABLEEN_Field is
     (
      --  Disabled. When there is AHB bus cachable read access, FlexSPI will
      --  not check whether it hit AHB TX Buffer.
      Cachableen_0,
      --  Enabled. When there is AHB bus cachable read access, FlexSPI will
      --  check whether it hit AHB TX Buffer first.
      Cachableen_1)
     with Size => 1;
   for AHBCR_CACHABLEEN_Field use
     (Cachableen_0 => 0,
      Cachableen_1 => 1);

   --  Enable AHB bus bufferable write access support. This field affects the
   --  last beat of AHB write access, refer for more details about AHB
   --  bufferable write.
   type AHBCR_BUFFERABLEEN_Field is
     (
      --  Disabled. For all AHB write access (no matter bufferable or
      --  non-bufferable ), FlexSPI will return AHB Bus ready after all data is
      --  transmitted to External device and AHB command finished.
      Bufferableen_0,
      --  Enabled. For AHB bufferable write access, FlexSPI will return AHB Bus
      --  ready when the AHB command is granted by arbitrator and will not wait
      --  for AHB command finished.
      Bufferableen_1)
     with Size => 1;
   for AHBCR_BUFFERABLEEN_Field use
     (Bufferableen_0 => 0,
      Bufferableen_1 => 1);

   --  AHB Read Address option bit. This option bit is intend to remove AHB
   --  burst start address alignment limitation.
   type AHBCR_READADDROPT_Field is
     (
      --  There is AHB read burst start address alignment limitation when flash
      --  is accessed in parallel mode or flash is wordaddressable.
      Readaddropt_0,
      --  There is no AHB read burst start address alignment limitation.
      --  FlexSPI will fetch more datas than AHB burst required to meet the
      --  alignment requirement.
      Readaddropt_1)
     with Size => 1;
   for AHBCR_READADDROPT_Field use
     (Readaddropt_0 => 0,
      Readaddropt_1 => 1);

   --  AHB Bus Control Register
   type AHBCR_Register is record
      --  Parallel mode enabled for AHB triggered Command (both read and write)
      --  .
      APAREN        : AHBCR_APAREN_Field := NRF_SVD.FlexSPI.Aparen_0;
      --  unspecified
      Reserved_1_2  : HAL.UInt2 := 16#0#;
      --  Enable AHB bus cachable read access support.
      CACHABLEEN    : AHBCR_CACHABLEEN_Field := NRF_SVD.FlexSPI.Cachableen_1;
      --  Enable AHB bus bufferable write access support. This field affects
      --  the last beat of AHB write access, refer for more details about AHB
      --  bufferable write.
      BUFFERABLEEN  : AHBCR_BUFFERABLEEN_Field :=
                       NRF_SVD.FlexSPI.Bufferableen_1;
      --  AHB Read Prefetch Enable.
      PREFETCHEN    : Boolean := False;
      --  AHB Read Address option bit. This option bit is intend to remove AHB
      --  burst start address alignment limitation.
      READADDROPT   : AHBCR_READADDROPT_Field :=
                       NRF_SVD.FlexSPI.Readaddropt_0;
      --  unspecified
      Reserved_7_31 : HAL.UInt25 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for AHBCR_Register use record
      APAREN        at 0 range 0 .. 0;
      Reserved_1_2  at 0 range 1 .. 2;
      CACHABLEEN    at 0 range 3 .. 3;
      BUFFERABLEEN  at 0 range 4 .. 4;
      PREFETCHEN    at 0 range 5 .. 5;
      READADDROPT   at 0 range 6 .. 6;
      Reserved_7_31 at 0 range 7 .. 31;
   end record;

   --  Interrupt Enable Register
   type INTEN_Register is record
      --  IP triggered Command Sequences Execution finished interrupt enable.
      IPCMDDONEEN     : Boolean := False;
      --  IP triggered Command Sequences Grant Timeout interrupt enable.
      IPCMDGEEN       : Boolean := False;
      --  AHB triggered Command Sequences Grant Timeout interrupt enable.
      AHBCMDGEEN      : Boolean := False;
      --  IP triggered Command Sequences Error Detected interrupt enable.
      IPCMDERREN      : Boolean := False;
      --  AHB triggered Command Sequences Error Detected interrupt enable.
      AHBCMDERREN     : Boolean := False;
      --  IP RX FIFO WaterMark available interrupt enable.
      IPRXWAEN        : Boolean := False;
      --  IP TX FIFO WaterMark empty interrupt enable.
      IPTXWEEN        : Boolean := False;
      --  unspecified
      Reserved_7_7    : HAL.Bit := 16#0#;
      --  SCK is stopped during command sequence because Async RX FIFO full
      --  interrupt enable.
      SCKSTOPBYRDEN   : Boolean := False;
      --  SCK is stopped during command sequence because Async TX FIFO empty
      --  interrupt enable.
      SCKSTOPBYWREN   : Boolean := False;
      --  AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
      AHBBUSTIMEOUTEN : Boolean := False;
      --  Sequence execution timeout interrupt enable.Refer Interrupts chapter
      --  for more details.
      SEQTIMEOUTEN    : Boolean := False;
      --  unspecified
      Reserved_12_31  : HAL.UInt20 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for INTEN_Register use record
      IPCMDDONEEN     at 0 range 0 .. 0;
      IPCMDGEEN       at 0 range 1 .. 1;
      AHBCMDGEEN      at 0 range 2 .. 2;
      IPCMDERREN      at 0 range 3 .. 3;
      AHBCMDERREN     at 0 range 4 .. 4;
      IPRXWAEN        at 0 range 5 .. 5;
      IPTXWEEN        at 0 range 6 .. 6;
      Reserved_7_7    at 0 range 7 .. 7;
      SCKSTOPBYRDEN   at 0 range 8 .. 8;
      SCKSTOPBYWREN   at 0 range 9 .. 9;
      AHBBUSTIMEOUTEN at 0 range 10 .. 10;
      SEQTIMEOUTEN    at 0 range 11 .. 11;
      Reserved_12_31  at 0 range 12 .. 31;
   end record;

   --  Interrupt Register
   type INTR_Register is record
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. IP triggered Command Sequences Execution finished
      --  interrupt. This interrupt is also generated when there is IPCMDGE or
      --  IPCMDERR interrupt generated.
      IPCMDDONE      : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. IP triggered Command Sequences Grant Timeout interrupt.
      IPCMDGE        : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. AHB triggered Command Sequences Grant Timeout
      --  interrupt.
      AHBCMDGE       : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. IP triggered Command Sequences Error Detected
      --  interrupt. When an error detected for IP command, this command will
      --  be ignored and not executed at all.
      IPCMDERR       : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. AHB triggered Command Sequences Error Detected
      --  interrupt. When an error detected for AHB command, this command will
      --  be ignored and not executed at all.
      AHBCMDERR      : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. IP RX FIFO watermark available interrupt.
      IPRXWA         : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. IP TX FIFO watermark empty interrupt.
      IPTXWE         : Boolean := True;
      --  unspecified
      Reserved_7_7   : HAL.Bit := 16#0#;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. SCK is stopped during command sequence because Async RX
      --  FIFO full interrupt.
      SCKSTOPBYRD    : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. SCK is stopped during command sequence because Async TX
      --  FIFO empty interrupt.
      SCKSTOPBYWR    : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. AHB Bus timeout interrupt.Refer Interrupts chapter for
      --  more details.
      AHBBUSTIMEOUT  : Boolean := False;
      --  Write data bit of one shall clear (set to zero) the corresponding bit
      --  in the field. Sequence execution timeout interrupt.
      SEQTIMEOUT     : Boolean := False;
      --  unspecified
      Reserved_12_31 : HAL.UInt20 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for INTR_Register use record
      IPCMDDONE      at 0 range 0 .. 0;
      IPCMDGE        at 0 range 1 .. 1;
      AHBCMDGE       at 0 range 2 .. 2;
      IPCMDERR       at 0 range 3 .. 3;
      AHBCMDERR      at 0 range 4 .. 4;
      IPRXWA         at 0 range 5 .. 5;
      IPTXWE         at 0 range 6 .. 6;
      Reserved_7_7   at 0 range 7 .. 7;
      SCKSTOPBYRD    at 0 range 8 .. 8;
      SCKSTOPBYWR    at 0 range 9 .. 9;
      AHBBUSTIMEOUT  at 0 range 10 .. 10;
      SEQTIMEOUT     at 0 range 11 .. 11;
      Reserved_12_31 at 0 range 12 .. 31;
   end record;

   --  LUT Control Register
   type LUTCR_Register is record
      --  Lock LUT
      LOCK          : Boolean := False;
      --  Unlock LUT
      UNLOCK        : Boolean := True;
      --  unspecified
      Reserved_2_31 : HAL.UInt30 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for LUTCR_Register use record
      LOCK          at 0 range 0 .. 0;
      UNLOCK        at 0 range 1 .. 1;
      Reserved_2_31 at 0 range 2 .. 31;
   end record;

   subtype AHBRXBUFCR0_BUFSZ_Field is HAL.UInt8;
   subtype AHBRXBUFCR0_MSTRID_Field is HAL.UInt4;
   subtype AHBRXBUFCR0_PRIORITY_Field is HAL.UInt2;

   --  AHB RX Buffer 0 Control Register 0
   type AHBRXBUFCR0_Register is record
      --  AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more
      --  details.
      BUFSZ          : AHBRXBUFCR0_BUFSZ_Field := 16#20#;
      --  unspecified
      Reserved_8_15  : HAL.UInt8 := 16#0#;
      --  This AHB RX Buffer is assigned according to AHB Master with ID
      --  (MSTR_ID). Please refer to for AHB RX Buffer allocation.
      MSTRID         : AHBRXBUFCR0_MSTRID_Field := 16#0#;
      --  unspecified
      Reserved_20_23 : HAL.UInt4 := 16#0#;
      --  This priority for AHB Master Read which this AHB RX Buffer is
      --  assigned. Refer for more details.
      PRIORITY       : AHBRXBUFCR0_PRIORITY_Field := 16#0#;
      --  unspecified
      Reserved_26_31 : HAL.UInt6 := 16#20#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for AHBRXBUFCR0_Register use record
      BUFSZ          at 0 range 0 .. 7;
      Reserved_8_15  at 0 range 8 .. 15;
      MSTRID         at 0 range 16 .. 19;
      Reserved_20_23 at 0 range 20 .. 23;
      PRIORITY       at 0 range 24 .. 25;
      Reserved_26_31 at 0 range 26 .. 31;
   end record;

   --  AHB RX Buffer 0 Control Register 0
   type AHBRXBUFCR0_Registers is array (0 .. 3) of AHBRXBUFCR0_Register
     with Volatile;

   subtype FLSHCR0_FLSHSZ_Field is HAL.UInt23;

   --  Flash A1 Control Register 0
   type FLSHCR0_Register is record
      --  Flash Size in KByte.
      FLSHSZ         : FLSHCR0_FLSHSZ_Field := 16#10000#;
      --  unspecified
      Reserved_23_31 : HAL.UInt9 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for FLSHCR0_Register use record
      FLSHSZ         at 0 range 0 .. 22;
      Reserved_23_31 at 0 range 23 .. 31;
   end record;

   --  Flash A1 Control Register 0
   type FLSHCR0_Registers is array (0 .. 3) of FLSHCR0_Register
     with Volatile;

   subtype FLSHCR1_TCSS_Field is HAL.UInt5;
   subtype FLSHCR1_TCSH_Field is HAL.UInt5;
   subtype FLSHCR1_CAS_Field is HAL.UInt4;

   --  CS interval unit
   type FLSHCR1_CSINTERVALUNIT_Field is
     (
      --  The CS interval unit is 1 serial clock cycle
      Csintervalunit_0,
      --  The CS interval unit is 256 serial clock cycle
      Csintervalunit_1)
     with Size => 1;
   for FLSHCR1_CSINTERVALUNIT_Field use
     (Csintervalunit_0 => 0,
      Csintervalunit_1 => 1);

   subtype FLSHCR1_CSINTERVAL_Field is HAL.UInt16;

   --  Flash A1 Control Register 1
   type FLSHCR1_Register is record
      --  Serial Flash CS setup time.
      TCSS           : FLSHCR1_TCSS_Field := 16#3#;
      --  Serial Flash CS Hold time.
      TCSH           : FLSHCR1_TCSH_Field := 16#3#;
      --  Word Addressable.
      WA             : Boolean := False;
      --  Column Address Size.
      CAS            : FLSHCR1_CAS_Field := 16#0#;
      --  CS interval unit
      CSINTERVALUNIT : FLSHCR1_CSINTERVALUNIT_Field :=
                        NRF_SVD.FlexSPI.Csintervalunit_0;
      --  This field is used to set the minimum interval between flash device
      --  Chip selection deassertion and flash device Chip selection assertion.
      --  If external flash has a limitation on the interval between command
      --  sequences, this field should be set accordingly. If there is no
      --  limitation, set this field with value 0x0.
      CSINTERVAL     : FLSHCR1_CSINTERVAL_Field := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for FLSHCR1_Register use record
      TCSS           at 0 range 0 .. 4;
      TCSH           at 0 range 5 .. 9;
      WA             at 0 range 10 .. 10;
      CAS            at 0 range 11 .. 14;
      CSINTERVALUNIT at 0 range 15 .. 15;
      CSINTERVAL     at 0 range 16 .. 31;
   end record;

   --  Flash A1 Control Register 1
   type FLSHCR1_Registers is array (0 .. 3) of FLSHCR1_Register
     with Volatile;

   subtype FLSHCR2_ARDSEQID_Field is HAL.UInt4;
   subtype FLSHCR2_ARDSEQNUM_Field is HAL.UInt3;
   subtype FLSHCR2_AWRSEQID_Field is HAL.UInt4;
   subtype FLSHCR2_AWRSEQNUM_Field is HAL.UInt3;
   subtype FLSHCR2_AWRWAIT_Field is HAL.UInt12;

   --  AWRWAIT unit
   type FLSHCR2_AWRWAITUNIT_Field is
     (
      --  The AWRWAIT unit is 2 ahb clock cycle
      Awrwaitunit_0,
      --  The AWRWAIT unit is 8 ahb clock cycle
      Awrwaitunit_1,
      --  The AWRWAIT unit is 32 ahb clock cycle
      Awrwaitunit_2,
      --  The AWRWAIT unit is 128 ahb clock cycle
      Awrwaitunit_3,
      --  The AWRWAIT unit is 512 ahb clock cycle
      Awrwaitunit_4,
      --  The AWRWAIT unit is 2048 ahb clock cycle
      Awrwaitunit_5,
      --  The AWRWAIT unit is 8192 ahb clock cycle
      Awrwaitunit_6,
      --  The AWRWAIT unit is 32768 ahb clock cycle
      Awrwaitunit_7)
     with Size => 3;
   for FLSHCR2_AWRWAITUNIT_Field use
     (Awrwaitunit_0 => 0,
      Awrwaitunit_1 => 1,
      Awrwaitunit_2 => 2,
      Awrwaitunit_3 => 3,
      Awrwaitunit_4 => 4,
      Awrwaitunit_5 => 5,
      Awrwaitunit_6 => 6,
      Awrwaitunit_7 => 7);

   --  Flash A1 Control Register 2
   type FLSHCR2_Register is record
      --  Sequence Index for AHB Read triggered Command in LUT.
      ARDSEQID       : FLSHCR2_ARDSEQID_Field := 16#0#;
      --  unspecified
      Reserved_4_4   : HAL.Bit := 16#0#;
      --  Sequence Number for AHB Read triggered Command in LUT.
      ARDSEQNUM      : FLSHCR2_ARDSEQNUM_Field := 16#0#;
      --  Sequence Index for AHB Write triggered Command.
      AWRSEQID       : FLSHCR2_AWRSEQID_Field := 16#0#;
      --  unspecified
      Reserved_12_12 : HAL.Bit := 16#0#;
      --  Sequence Number for AHB Write triggered Command.
      AWRSEQNUM      : FLSHCR2_AWRSEQNUM_Field := 16#0#;
      --  For certain devices (such as FPGA), it need some time to write data
      --  into internal memory after the command sequences finished on FlexSPI
      --  interface
      AWRWAIT        : FLSHCR2_AWRWAIT_Field := 16#0#;
      --  AWRWAIT unit
      AWRWAITUNIT    : FLSHCR2_AWRWAITUNIT_Field :=
                        NRF_SVD.FlexSPI.Awrwaitunit_0;
      --  Clear the instruction pointer which is internally saved pointer by
      --  JMP_ON_CS. Refer Programmable Sequence Engine for details.
      CLRINSTRPTR    : Boolean := False;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for FLSHCR2_Register use record
      ARDSEQID       at 0 range 0 .. 3;
      Reserved_4_4   at 0 range 4 .. 4;
      ARDSEQNUM      at 0 range 5 .. 7;
      AWRSEQID       at 0 range 8 .. 11;
      Reserved_12_12 at 0 range 12 .. 12;
      AWRSEQNUM      at 0 range 13 .. 15;
      AWRWAIT        at 0 range 16 .. 27;
      AWRWAITUNIT    at 0 range 28 .. 30;
      CLRINSTRPTR    at 0 range 31 .. 31;
   end record;

   --  Flash A1 Control Register 2
   type FLSHCR2_Registers is array (0 .. 3) of FLSHCR2_Register
     with Volatile;

   --  Write mask option bit 1. This option bit could be used to remove AHB
   --  write burst start address alignment limitation.
   type FLSHCR4_WMOPT1_Field is
     (
      --  DQS pin will be used as Write Mask when writing to external device.
      --  There is no limitation on AHB write burst start address alignment
      --  when flash is accessed in individual mode.
      Wmopt1_0,
      --  DQS pin will not be used as Write Mask when writing to external
      --  device. There is limitation on AHB write burst start address
      --  alignment when flash is accessed in individual mode.
      Wmopt1_1)
     with Size => 1;
   for FLSHCR4_WMOPT1_Field use
     (Wmopt1_0 => 0,
      Wmopt1_1 => 1);

   --  Write mask enable bit for flash device on port A. When write mask
   --  function is needed for memory device on port A, this bit must be set.
   type FLSHCR4_WMENA_Field is
     (
      --  Write mask is disabled, DQS(RWDS) pin will be un-driven when writing
      --  to external device.
      Wmena_0,
      --  Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as
      --  write mask output when writing to external device.
      Wmena_1)
     with Size => 1;
   for FLSHCR4_WMENA_Field use
     (Wmena_0 => 0,
      Wmena_1 => 1);

   --  Write mask enable bit for flash device on port B. When write mask
   --  function is needed for memory device on port B, this bit must be set.
   type FLSHCR4_WMENB_Field is
     (
      --  Write mask is disabled, DQS(RWDS) pin will be un-driven when writing
      --  to external device.
      Wmenb_0,
      --  Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as
      --  write mask output when writing to external device.
      Wmenb_1)
     with Size => 1;
   for FLSHCR4_WMENB_Field use
     (Wmenb_0 => 0,
      Wmenb_1 => 1);

   --  Flash Control Register 4
   type FLSHCR4_Register is record
      --  Write mask option bit 1. This option bit could be used to remove AHB
      --  write burst start address alignment limitation.
      WMOPT1        : FLSHCR4_WMOPT1_Field := NRF_SVD.FlexSPI.Wmopt1_0;
      --  unspecified
      Reserved_1_1  : HAL.Bit := 16#0#;
      --  Write mask enable bit for flash device on port A. When write mask
      --  function is needed for memory device on port A, this bit must be set.
      WMENA         : FLSHCR4_WMENA_Field := NRF_SVD.FlexSPI.Wmena_0;
      --  Write mask enable bit for flash device on port B. When write mask
      --  function is needed for memory device on port B, this bit must be set.
      WMENB         : FLSHCR4_WMENB_Field := NRF_SVD.FlexSPI.Wmenb_0;
      --  unspecified
      Reserved_4_31 : HAL.UInt28 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for FLSHCR4_Register use record
      WMOPT1        at 0 range 0 .. 0;
      Reserved_1_1  at 0 range 1 .. 1;
      WMENA         at 0 range 2 .. 2;
      WMENB         at 0 range 3 .. 3;
      Reserved_4_31 at 0 range 4 .. 31;
   end record;

   subtype IPCR1_IDATSZ_Field is HAL.UInt16;
   subtype IPCR1_ISEQID_Field is HAL.UInt4;
   subtype IPCR1_ISEQNUM_Field is HAL.UInt3;

   --  Parallel mode Enabled for IP command.
   type IPCR1_IPAREN_Field is
     (
      --  Flash will be accessed in Individual mode.
      Iparen_0,
      --  Flash will be accessed in Parallel mode.
      Iparen_1)
     with Size => 1;
   for IPCR1_IPAREN_Field use
     (Iparen_0 => 0,
      Iparen_1 => 1);

   --  IP Control Register 1
   type IPCR1_Register is record
      --  Flash Read/Program Data Size (in Bytes) for IP command.
      IDATSZ         : IPCR1_IDATSZ_Field := 16#0#;
      --  Sequence Index in LUT for IP command.
      ISEQID         : IPCR1_ISEQID_Field := 16#0#;
      --  unspecified
      Reserved_20_23 : HAL.UInt4 := 16#0#;
      --  Sequence Number for IP command: ISEQNUM+1.
      ISEQNUM        : IPCR1_ISEQNUM_Field := 16#0#;
      --  unspecified
      Reserved_27_30 : HAL.UInt4 := 16#0#;
      --  Parallel mode Enabled for IP command.
      IPAREN         : IPCR1_IPAREN_Field := NRF_SVD.FlexSPI.Iparen_0;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for IPCR1_Register use record
      IDATSZ         at 0 range 0 .. 15;
      ISEQID         at 0 range 16 .. 19;
      Reserved_20_23 at 0 range 20 .. 23;
      ISEQNUM        at 0 range 24 .. 26;
      Reserved_27_30 at 0 range 27 .. 30;
      IPAREN         at 0 range 31 .. 31;
   end record;

   --  IP Command Register
   type IPCMD_Register is record
      --  Setting this bit will trigger an IP Command.
      TRG           : Boolean := False;
      --  unspecified
      Reserved_1_31 : HAL.UInt31 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for IPCMD_Register use record
      TRG           at 0 range 0 .. 0;
      Reserved_1_31 at 0 range 1 .. 31;
   end record;

   --  IP RX FIFO reading by DMA enabled.
   type IPRXFCR_RXDMAEN_Field is
     (
      --  IP RX FIFO would be read by processor.
      Rxdmaen_0,
      --  IP RX FIFO would be read by DMA.
      Rxdmaen_1)
     with Size => 1;
   for IPRXFCR_RXDMAEN_Field use
     (Rxdmaen_0 => 0,
      Rxdmaen_1 => 1);

   subtype IPRXFCR_RXWMRK_Field is HAL.UInt4;

   --  IP RX FIFO Control Register
   type IPRXFCR_Register is record
      --  Clear all valid data entries in IP RX FIFO.
      CLRIPRXF      : Boolean := False;
      --  IP RX FIFO reading by DMA enabled.
      RXDMAEN       : IPRXFCR_RXDMAEN_Field := NRF_SVD.FlexSPI.Rxdmaen_0;
      --  Watermark level is (RXWMRK+1)*64 Bits.
      RXWMRK        : IPRXFCR_RXWMRK_Field := 16#0#;
      --  unspecified
      Reserved_6_31 : HAL.UInt26 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for IPRXFCR_Register use record
      CLRIPRXF      at 0 range 0 .. 0;
      RXDMAEN       at 0 range 1 .. 1;
      RXWMRK        at 0 range 2 .. 5;
      Reserved_6_31 at 0 range 6 .. 31;
   end record;

   --  IP TX FIFO filling by DMA enabled.
   type IPTXFCR_TXDMAEN_Field is
     (
      --  IP TX FIFO would be filled by processor.
      Txdmaen_0,
      --  IP TX FIFO would be filled by DMA.
      Txdmaen_1)
     with Size => 1;
   for IPTXFCR_TXDMAEN_Field use
     (Txdmaen_0 => 0,
      Txdmaen_1 => 1);

   subtype IPTXFCR_TXWMRK_Field is HAL.UInt4;

   --  IP TX FIFO Control Register
   type IPTXFCR_Register is record
      --  Clear all valid data entries in IP TX FIFO.
      CLRIPTXF      : Boolean := False;
      --  IP TX FIFO filling by DMA enabled.
      TXDMAEN       : IPTXFCR_TXDMAEN_Field := NRF_SVD.FlexSPI.Txdmaen_0;
      --  Watermark level is (TXWMRK+1)*64 Bits.
      TXWMRK        : IPTXFCR_TXWMRK_Field := 16#0#;
      --  unspecified
      Reserved_6_31 : HAL.UInt26 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for IPTXFCR_Register use record
      CLRIPTXF      at 0 range 0 .. 0;
      TXDMAEN       at 0 range 1 .. 1;
      TXWMRK        at 0 range 2 .. 5;
      Reserved_6_31 at 0 range 6 .. 31;
   end record;

   subtype DLLCR_SLVDLYTARGET_Field is HAL.UInt4;
   subtype DLLCR_OVRDVAL_Field is HAL.UInt6;

   --  DLL Control Register 0
   type DLLCR_Register is record
      --  DLL calibration enable.
      DLLEN          : Boolean := False;
      --  Software could force a reset on DLL by setting this field to 0x1.
      --  This will cause the DLL to lose lock and re-calibrate to detect an
      --  ref_clock half period phase shift. The reset action is edge
      --  triggered, so software need to clear this bit after set this bit (no
      --  delay limitation).
      DLLRESET       : Boolean := False;
      --  unspecified
      Reserved_2_2   : HAL.Bit := 16#0#;
      --  The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 *
      --  clock cycle of reference clock (serial clock).
      SLVDLYTARGET   : DLLCR_SLVDLYTARGET_Field := 16#0#;
      --  unspecified
      Reserved_7_7   : HAL.Bit := 16#0#;
      --  Slave clock delay line delay cell number selection override enable.
      OVRDEN         : Boolean := True;
      --  Slave clock delay line delay cell number selection override value.
      OVRDVAL        : DLLCR_OVRDVAL_Field := 16#0#;
      --  unspecified
      Reserved_15_31 : HAL.UInt17 := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for DLLCR_Register use record
      DLLEN          at 0 range 0 .. 0;
      DLLRESET       at 0 range 1 .. 1;
      Reserved_2_2   at 0 range 2 .. 2;
      SLVDLYTARGET   at 0 range 3 .. 6;
      Reserved_7_7   at 0 range 7 .. 7;
      OVRDEN         at 0 range 8 .. 8;
      OVRDVAL        at 0 range 9 .. 14;
      Reserved_15_31 at 0 range 15 .. 31;
   end record;

   --  DLL Control Register 0
   type DLLCR_Registers is array (0 .. 1) of DLLCR_Register
     with Volatile;

   --  This status field indicates the trigger source of current command
   --  sequence granted by arbitrator. This field value is meaningless when
   --  ARB_CTL is not busy (STS0[ARBIDLE]=0x1).
   type STS0_ARBCMDSRC_Field is
     (
      --  Triggered by AHB read command (triggered by AHB read).
      Arbcmdsrc_0,
      --  Triggered by AHB write command (triggered by AHB Write).
      Arbcmdsrc_1,
      --  Triggered by IP command (triggered by setting register bit
      --  IPCMD.TRG).
      Arbcmdsrc_2,
      --  Triggered by suspended command (resumed).
      Arbcmdsrc_3)
     with Size => 2;
   for STS0_ARBCMDSRC_Field use
     (Arbcmdsrc_0 => 0,
      Arbcmdsrc_1 => 1,
      Arbcmdsrc_2 => 2,
      Arbcmdsrc_3 => 3);

   --  Status Register 0
   type STS0_Register is record
      --  Read-only. This status bit indicates the state machine in SEQ_CTL is
      --  idle and there is command sequence executing on FlexSPI interface.
      SEQIDLE       : Boolean;
      --  Read-only. This status bit indicates the state machine in ARB_CTL is
      --  busy and there is command sequence granted by arbitrator and not
      --  finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1)
      --  is idle, there will be no transaction on FlexSPI interface also
      --  (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI
      --  controller become idle instead of SEQIDLE.
      ARBIDLE       : Boolean;
      --  Read-only. This status field indicates the trigger source of current
      --  command sequence granted by arbitrator. This field value is
      --  meaningless when ARB_CTL is not busy (STS0[ARBIDLE]=0x1).
      ARBCMDSRC     : STS0_ARBCMDSRC_Field;
      --  unspecified
      Reserved_4_31 : HAL.UInt28;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for STS0_Register use record
      SEQIDLE       at 0 range 0 .. 0;
      ARBIDLE       at 0 range 1 .. 1;
      ARBCMDSRC     at 0 range 2 .. 3;
      Reserved_4_31 at 0 range 4 .. 31;
   end record;

   subtype STS1_AHBCMDERRID_Field is HAL.UInt4;

   --  Indicates the Error Code when AHB command Error detected. This field
   --  will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
   type STS1_AHBCMDERRCODE_Field is
     (
      --  No error.
      Ahbcmderrcode_0,
      --  AHB Write command with JMP_ON_CS instruction used in the sequence.
      Ahbcmderrcode_2,
      --  There is unknown instruction opcode in the sequence.
      Ahbcmderrcode_3,
      --  Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
      Ahbcmderrcode_4,
      --  Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
      Ahbcmderrcode_5,
      --  Sequence execution timeout.
      Ahbcmderrcode_14)
     with Size => 4;
   for STS1_AHBCMDERRCODE_Field use
     (Ahbcmderrcode_0 => 0,
      Ahbcmderrcode_2 => 2,
      Ahbcmderrcode_3 => 3,
      Ahbcmderrcode_4 => 4,
      Ahbcmderrcode_5 => 5,
      Ahbcmderrcode_14 => 14);

   subtype STS1_IPCMDERRID_Field is HAL.UInt4;

   --  Indicates the Error Code when IP command Error detected. This field will
   --  be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
   type STS1_IPCMDERRCODE_Field is
     (
      --  No error.
      Ipcmderrcode_0,
      --  IP command with JMP_ON_CS instruction used in the sequence.
      Ipcmderrcode_2,
      --  There is unknown instruction opcode in the sequence.
      Ipcmderrcode_3,
      --  Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
      Ipcmderrcode_4,
      --  Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
      Ipcmderrcode_5,
      --  Flash access start address exceed the whole flash address range
      --  (A1/A2/B1/B2).
      Ipcmderrcode_6,
      --  Sequence execution timeout.
      Ipcmderrcode_14,
      --  Flash boundary crossed.
      Ipcmderrcode_15)
     with Size => 4;
   for STS1_IPCMDERRCODE_Field use
     (Ipcmderrcode_0 => 0,
      Ipcmderrcode_2 => 2,
      Ipcmderrcode_3 => 3,
      Ipcmderrcode_4 => 4,
      Ipcmderrcode_5 => 5,
      Ipcmderrcode_6 => 6,
      Ipcmderrcode_14 => 14,
      Ipcmderrcode_15 => 15);

   --  Status Register 1
   type STS1_Register is record
      --  Read-only. Indicates the sequence index when an AHB command error is
      --  detected. This field will be cleared when INTR[AHBCMDERR] is
      --  write-1-clear(w1c).
      AHBCMDERRID    : STS1_AHBCMDERRID_Field;
      --  unspecified
      Reserved_4_7   : HAL.UInt4;
      --  Read-only. Indicates the Error Code when AHB command Error detected.
      --  This field will be cleared when INTR[AHBCMDERR] is
      --  write-1-clear(w1c).
      AHBCMDERRCODE  : STS1_AHBCMDERRCODE_Field;
      --  unspecified
      Reserved_12_15 : HAL.UInt4;
      --  Read-only. Indicates the sequence Index when IP command error
      --  detected. This field will be cleared when INTR[IPCMDERR] is
      --  write-1-clear(w1c).
      IPCMDERRID     : STS1_IPCMDERRID_Field;
      --  unspecified
      Reserved_20_23 : HAL.UInt4;
      --  Read-only. Indicates the Error Code when IP command Error detected.
      --  This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
      IPCMDERRCODE   : STS1_IPCMDERRCODE_Field;
      --  unspecified
      Reserved_28_31 : HAL.UInt4;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for STS1_Register use record
      AHBCMDERRID    at 0 range 0 .. 3;
      Reserved_4_7   at 0 range 4 .. 7;
      AHBCMDERRCODE  at 0 range 8 .. 11;
      Reserved_12_15 at 0 range 12 .. 15;
      IPCMDERRID     at 0 range 16 .. 19;
      Reserved_20_23 at 0 range 20 .. 23;
      IPCMDERRCODE   at 0 range 24 .. 27;
      Reserved_28_31 at 0 range 28 .. 31;
   end record;

   subtype STS2_ASLVSEL_Field is HAL.UInt6;
   subtype STS2_AREFSEL_Field is HAL.UInt6;
   subtype STS2_BSLVSEL_Field is HAL.UInt6;
   subtype STS2_BREFSEL_Field is HAL.UInt6;

   --  Status Register 2
   type STS2_Register is record
      --  Read-only. Flash A sample clock slave delay line locked.
      ASLVLOCK       : Boolean;
      --  Read-only. Flash A sample clock reference delay line locked.
      AREFLOCK       : Boolean;
      --  Read-only. Flash A sample clock slave delay line delay cell number
      --  selection .
      ASLVSEL        : STS2_ASLVSEL_Field;
      --  Read-only. Flash A sample clock reference delay line delay cell
      --  number selection.
      AREFSEL        : STS2_AREFSEL_Field;
      --  unspecified
      Reserved_14_15 : HAL.UInt2;
      --  Read-only. Flash B sample clock slave delay line locked.
      BSLVLOCK       : Boolean;
      --  Read-only. Flash B sample clock reference delay line locked.
      BREFLOCK       : Boolean;
      --  Read-only. Flash B sample clock slave delay line delay cell number
      --  selection.
      BSLVSEL        : STS2_BSLVSEL_Field;
      --  Read-only. Flash B sample clock reference delay line delay cell
      --  number selection.
      BREFSEL        : STS2_BREFSEL_Field;
      --  unspecified
      Reserved_30_31 : HAL.UInt2;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for STS2_Register use record
      ASLVLOCK       at 0 range 0 .. 0;
      AREFLOCK       at 0 range 1 .. 1;
      ASLVSEL        at 0 range 2 .. 7;
      AREFSEL        at 0 range 8 .. 13;
      Reserved_14_15 at 0 range 14 .. 15;
      BSLVLOCK       at 0 range 16 .. 16;
      BREFLOCK       at 0 range 17 .. 17;
      BSLVSEL        at 0 range 18 .. 23;
      BREFSEL        at 0 range 24 .. 29;
      Reserved_30_31 at 0 range 30 .. 31;
   end record;

   subtype AHBSPNDSTS_BUFID_Field is HAL.UInt3;
   subtype AHBSPNDSTS_DATLFT_Field is HAL.UInt16;

   --  AHB Suspend Status Register
   type AHBSPNDSTS_Register is record
      --  Read-only. Indicates if an AHB read prefetch command sequence has
      --  been suspended.
      ACTIVE        : Boolean;
      --  Read-only. AHB RX BUF ID for suspended command sequence.
      BUFID         : AHBSPNDSTS_BUFID_Field;
      --  unspecified
      Reserved_4_15 : HAL.UInt12;
      --  Read-only. Left Data size for suspended command sequence (in byte).
      DATLFT        : AHBSPNDSTS_DATLFT_Field;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for AHBSPNDSTS_Register use record
      ACTIVE        at 0 range 0 .. 0;
      BUFID         at 0 range 1 .. 3;
      Reserved_4_15 at 0 range 4 .. 15;
      DATLFT        at 0 range 16 .. 31;
   end record;

   subtype IPRXFSTS_FILL_Field is HAL.UInt8;
   subtype IPRXFSTS_RDCNTR_Field is HAL.UInt16;

   --  IP RX FIFO Status Register
   type IPRXFSTS_Register is record
      --  Read-only. Fill level of IP RX FIFO.
      FILL          : IPRXFSTS_FILL_Field;
      --  unspecified
      Reserved_8_15 : HAL.UInt8;
      --  Read-only. Total Read Data Counter: RDCNTR * 64 Bits.
      RDCNTR        : IPRXFSTS_RDCNTR_Field;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for IPRXFSTS_Register use record
      FILL          at 0 range 0 .. 7;
      Reserved_8_15 at 0 range 8 .. 15;
      RDCNTR        at 0 range 16 .. 31;
   end record;

   subtype IPTXFSTS_FILL_Field is HAL.UInt8;
   subtype IPTXFSTS_WRCNTR_Field is HAL.UInt16;

   --  IP TX FIFO Status Register
   type IPTXFSTS_Register is record
      --  Read-only. Fill level of IP TX FIFO.
      FILL          : IPTXFSTS_FILL_Field;
      --  unspecified
      Reserved_8_15 : HAL.UInt8;
      --  Read-only. Total Write Data Counter: WRCNTR * 64 Bits.
      WRCNTR        : IPTXFSTS_WRCNTR_Field;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for IPTXFSTS_Register use record
      FILL          at 0 range 0 .. 7;
      Reserved_8_15 at 0 range 8 .. 15;
      WRCNTR        at 0 range 16 .. 31;
   end record;

   --  IP RX FIFO Data Register 0

   --  IP RX FIFO Data Register 0
   type RFDR_Registers is array (0 .. 31) of HAL.UInt32
     with Volatile;

   --  IP TX FIFO Data Register 0

   --  IP TX FIFO Data Register 0
   type TFDR_Registers is array (0 .. 31) of HAL.UInt32
     with Volatile;

   subtype LUT_OPERAND0_Field is HAL.UInt8;
   subtype LUT_NUM_PADS0_Field is HAL.UInt2;
   subtype LUT_OPCODE0_Field is HAL.UInt6;
   subtype LUT_OPERAND1_Field is HAL.UInt8;
   subtype LUT_NUM_PADS1_Field is HAL.UInt2;
   subtype LUT_OPCODE1_Field is HAL.UInt6;

   --  LUT 0
   type LUT_Register is record
      --  OPERAND0
      OPERAND0  : LUT_OPERAND0_Field := 16#0#;
      --  NUM_PADS0
      NUM_PADS0 : LUT_NUM_PADS0_Field := 16#0#;
      --  OPCODE
      OPCODE0   : LUT_OPCODE0_Field := 16#0#;
      --  OPERAND1
      OPERAND1  : LUT_OPERAND1_Field := 16#0#;
      --  NUM_PADS1
      NUM_PADS1 : LUT_NUM_PADS1_Field := 16#0#;
      --  OPCODE1
      OPCODE1   : LUT_OPCODE1_Field := 16#0#;
   end record
     with Volatile_Full_Access, Size => 32,
          Bit_Order => System.Low_Order_First;

   for LUT_Register use record
      OPERAND0  at 0 range 0 .. 7;
      NUM_PADS0 at 0 range 8 .. 9;
      OPCODE0   at 0 range 10 .. 15;
      OPERAND1  at 0 range 16 .. 23;
      NUM_PADS1 at 0 range 24 .. 25;
      OPCODE1   at 0 range 26 .. 31;
   end record;

   --  LUT 0
   type LUT_Registers is array (0 .. 63) of LUT_Register
     with Volatile;

   -----------------
   -- Peripherals --
   -----------------

   --  FlexSPI
   type FLEXSPI_Peripheral is record
      --  Module Control Register 0
      MCR0        : aliased MCR0_Register;
      --  Module Control Register 1
      MCR1        : aliased MCR1_Register;
      --  Module Control Register 2
      MCR2        : aliased MCR2_Register;
      --  AHB Bus Control Register
      AHBCR       : aliased AHBCR_Register;
      --  Interrupt Enable Register
      INTEN       : aliased INTEN_Register;
      --  Interrupt Register
      INTR        : aliased INTR_Register;
      --  LUT Key Register
      LUTKEY      : aliased HAL.UInt32;
      --  LUT Control Register
      LUTCR       : aliased LUTCR_Register;
      --  AHB RX Buffer 0 Control Register 0
      AHBRXBUFCR0 : aliased AHBRXBUFCR0_Registers;
      --  Flash A1 Control Register 0
      FLSHCR0     : aliased FLSHCR0_Registers;
      --  Flash A1 Control Register 1
      FLSHCR1     : aliased FLSHCR1_Registers;
      --  Flash A1 Control Register 2
      FLSHCR2     : aliased FLSHCR2_Registers;
      --  Flash Control Register 4
      FLSHCR4     : aliased FLSHCR4_Register;
      --  IP Control Register 0
      IPCR0       : aliased HAL.UInt32;
      --  IP Control Register 1
      IPCR1       : aliased IPCR1_Register;
      --  IP Command Register
      IPCMD       : aliased IPCMD_Register;
      --  IP RX FIFO Control Register
      IPRXFCR     : aliased IPRXFCR_Register;
      --  IP TX FIFO Control Register
      IPTXFCR     : aliased IPTXFCR_Register;
      --  DLL Control Register 0
      DLLCR       : aliased DLLCR_Registers;
      --  Status Register 0
      STS0        : aliased STS0_Register;
      --  Status Register 1
      STS1        : aliased STS1_Register;
      --  Status Register 2
      STS2        : aliased STS2_Register;
      --  AHB Suspend Status Register
      AHBSPNDSTS  : aliased AHBSPNDSTS_Register;
      --  IP RX FIFO Status Register
      IPRXFSTS    : aliased IPRXFSTS_Register;
      --  IP TX FIFO Status Register
      IPTXFSTS    : aliased IPTXFSTS_Register;
      --  IP RX FIFO Data Register 0
      RFDR        : aliased RFDR_Registers;
      --  IP TX FIFO Data Register 0
      TFDR        : aliased TFDR_Registers;
      --  LUT 0
      LUT         : aliased LUT_Registers;
   end record
     with Volatile;

   for FLEXSPI_Peripheral use record
      MCR0        at 16#0# range 0 .. 31;
      MCR1        at 16#4# range 0 .. 31;
      MCR2        at 16#8# range 0 .. 31;
      AHBCR       at 16#C# range 0 .. 31;
      INTEN       at 16#10# range 0 .. 31;
      INTR        at 16#14# range 0 .. 31;
      LUTKEY      at 16#18# range 0 .. 31;
      LUTCR       at 16#1C# range 0 .. 31;
      AHBRXBUFCR0 at 16#20# range 0 .. 127;
      FLSHCR0     at 16#60# range 0 .. 127;
      FLSHCR1     at 16#70# range 0 .. 127;
      FLSHCR2     at 16#80# range 0 .. 127;
      FLSHCR4     at 16#94# range 0 .. 31;
      IPCR0       at 16#A0# range 0 .. 31;
      IPCR1       at 16#A4# range 0 .. 31;
      IPCMD       at 16#B0# range 0 .. 31;
      IPRXFCR     at 16#B8# range 0 .. 31;
      IPTXFCR     at 16#BC# range 0 .. 31;
      DLLCR       at 16#C0# range 0 .. 63;
      STS0        at 16#E0# range 0 .. 31;
      STS1        at 16#E4# range 0 .. 31;
      STS2        at 16#E8# range 0 .. 31;
      AHBSPNDSTS  at 16#EC# range 0 .. 31;
      IPRXFSTS    at 16#F0# range 0 .. 31;
      IPTXFSTS    at 16#F4# range 0 .. 31;
      RFDR        at 16#100# range 0 .. 1023;
      TFDR        at 16#180# range 0 .. 1023;
      LUT         at 16#200# range 0 .. 2047;
   end record;

   --  FlexSPI
   FLEXSPI_Periph : aliased FLEXSPI_Peripheral
     with Import, Address => System'To_Address (16#402A8000#);

end NRF_SVD.FlexSPI;
